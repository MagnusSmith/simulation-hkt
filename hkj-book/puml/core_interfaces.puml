@startuml

!include https://raw.githubusercontent.com/ncosta-ic/catppuccin-macchiato-plantuml-theme/main/theme.puml

title Core HKT Simulation Interfaces and Patterns

left to right direction

package "HKT Core - Type Classes" {
    interface "Kind<F_WITNESS, A>" as Kind {
      ' F_WITNESS is the phantom type (e.g., XKind.Witness)
      ' A is the value type
    }
    interface "Functor<F_WITNESS>" as Functor {
        + map(fn: Function<A,B>, fa: Kind<F_WITNESS,A>) : Kind<F_WITNESS,B>
    }
    interface "Applicative<F_WITNESS>" as Applicative {
        + of(value: A) : Kind<F_WITNESS,A>
        + ap(ff: Kind<F_WITNESS, Function<A,B>>, fa: Kind<F_WITNESS,A>) : Kind<F_WITNESS,B>
        ' mapN methods can be shown if desired, but are often defaults
        ' + map2(Kind<F_WITNESS,A>, Kind<F_WITNESS,B>, BiFunction<A,B,C>) : Kind<F_WITNESS,C>
    }
    interface "Monad<F_WITNESS>" as Monad {
        + flatMap(fn: Function<A, Kind<F_WITNESS,B>>, ma: Kind<F_WITNESS,A>) : Kind<F_WITNESS,B>
    }
    interface "MonadError<F_WITNESS, E>" as MonadError {
        + raiseError(error: E) : Kind<F_WITNESS,A>
        + handleErrorWith(ma: Kind<F_WITNESS,A>, handler: Function<E, Kind<F_WITNESS,A>>) : Kind<F_WITNESS,A>
        ' Other recovery methods can be shown if desired
    }

    Functor ..> Kind : (operates on)
    Applicative --|> Functor
    Monad --|> Applicative
    MonadError --|> Monad
}
package "Defunctionalisation Pattern Details" {
    class KindUnwrapException

    package "For External Types (Optional etc)" {
        interface "OptionalKind<A>" as OptionalKindInterface extends Kind<OptionalKind.Witness, A> {
            class Witness {} ' Nested phantom Witness type
        }
        class "java.util.Optional<A>" as JavaOptional {}

        ' OptionalHolder is an internal implementation detail of OptionalKindHelper
        package "internal" {
            class "OptionalHolder<A>" as OptionalHolder implements OptionalKindInterface {
             + OptionalHolder(opt: java.util.Optional<A>)
            }
        }
        OptionalKindHelper ..> OptionalHolder : "creates / uses"
        OptionalKindHelper ..> JavaOptional : "wraps / unwraps"
        OptionalHolder ..> JavaOptional : "holds"

        class "OptionalKindHelper" as OptionalKindHelper {
            + {static} wrap(opt: java.util.Optional<A>): Kind<OptionalKind.Witness, A>
            + {static} unwrap(kind: Kind<OptionalKind.Witness, A>): java.util.Optional<A>
        }
        class "OptionalMonad" as OptionalMonad implements MonadError<OptionalKind.Witness, java.lang.Void> {
            ' Uses OptionalKindHelper
        }
        OptionalMonad ..> OptionalKindHelper : "uses"
    }

    package "For Library-Defined Types (Id, Maybe, IO, Transformers)" {
        interface "IdKind<A>" as IdKindInterface extends Kind<Id.Witness, A> {
            class Witness {} ' Nested phantom Witness type
        }
        ' Id<A> itself implements IdKind<A>
        class "Id<A>(value: A)" as IdRecord implements IdKindInterface {
        }
        IdRecord --|> IdKindInterface

        class "IdKindHelper" as IdKindHelper {
            + {static} wrap(id: Id<A>): Kind<Id.Witness, A>
            + {static} unwrap(kind: Kind<Id.Witness, A>): Id<A>
        }
        IdKindHelper ..> IdRecord : "casts to/from"

        class "IdentityMonad" as IdentityMonad implements Monad<Id.Witness> {
            ' Uses IdKindHelper
        }
        IdentityMonad ..> IdKindHelper : "uses"
    }
}
@enduml

